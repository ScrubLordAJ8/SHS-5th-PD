--------------------------------------------------------------------------------
Section 0 - Line up
--------------------------------------------------------------------------------
Player 0 (P0): E0, Collude
        Always collude.
Player 1 (P1): E1, Betray
        Always betray.
Player 2 (P2): E2, Alternate
        Collude, then alternate.
Player 3 (P3): E3, Collude but retaliate
        Collude first round. Collude, except in a round after getting 
        a severe punishment.
Player 4 (P4): E4, Use early history
        Collude first round. Compare all rounds to the previous round and 
        assume opponent will behave the same as the first time the previous 
        round's result occurred. If the previous round's result never has 
        happened, collude except after being severly punished.
Player 5 (P5): E5, Collude first 100 rounds unless betrayed. Betray 101st round forward.
        Betray if ever betrayed.
        If I haven't been betrayed yet, I'll betray starting with the 100th roun
        d.
Player 6 (P6): E6, Collude until betrayed
        Collude first round. Collude, unless betrayed; then always betray.
Player 7 (P7): E7, Error
        return '', ' ', or int 4
Player 8 (P8): Byte Me, The Social Experiment
        Start with collude until betrayed, then goes to soft majority
--------------------------------------------------------------------------------
Section 1 - Player vs. Player
--------------------------------------------------------------------------------
Each column shows pts/round earned against each other player:
             P0     P1     P2     P3     P4     P5     P6     P7     P8
vs. P0 :      0    100     50      0      0     48      0   -250     99
vs. P1 :   -500      0   -375   -375   -254   -252   -252   -250   -357
vs. P2 :   -250    -75      0   -201   -201    -77    -78   -250    -76
vs. P3 :      0    -75   -198      0      0    -25      0   -250    -75
vs. P4 :      0   -246   -198      0      0    -90      0   -250   -245
vs. P5 :   -244   -248   -371   -130    -98      0   -124   -250   -246
vs. P6 :      0   -248   -370      0      0   -121      0   -250   -246
vs. P7 :   -250   -250   -250   -250   -250   -250   -250      0   -250
vs. P8 :   -496   -102   -371   -373   -252   -250   -250   -250      0
TOTAL  :  -1740  -1144  -2083  -1329  -1055  -1017   -954  -2000  -1396
--------------------------------------------------------------------------------
Section 2 - Leaderboard
--------------------------------------------------------------------------------
Average points per round:
Team name (P#):  Score      with strategy name
E6        (P6):       -106 points with Collude until betrayed                  
E5        (P5):       -113 points with Collude first 100 rounds unless betrayed
E4        (P4):       -118 points with Use early history                       
E1        (P1):       -128 points with Betray                                  
E3        (P3):       -148 points with Collude but retaliate                   
Byte Me   (P8):       -156 points with The Social Experiment                   
E0        (P0):       -194 points with Collude                                 
E7        (P7):       -223 points with Error                                   
E2        (P2):       -232 points with Alternate                               
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
example0--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####

team_name = 'E0'
strategy_name = 'Collude'
strategy_description = 'Always collude.'
    
def move(my_history, their_history, my_score, their_score):
    '''Make my move based on the history with this player.
    
    history: a string with one letter (c or b) per round that has been played with this opponent.
    their_history: a string of the same length as history, possibly empty. 
    The first round between these two players is my_history[0] and their_history[0]
    The most recent round is my_history[-1] and their_history[-1]
    
    Returns 'c' or 'b' for collude or betray.
    '''
    
    # This player always colludes.
    return 'c'
    --------------------------------------------------------------------------------
example1--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####

team_name = 'E1'
strategy_name = 'Betray'
strategy_description = 'Always betray.'
    
def move(my_history, their_history, my_score, their_score):
    '''Make my move based on the history with this player.
    
    history: a string with one letter (c or b) per round that has been played with this opponent.
    their_history: a string of the same length as history, possibly empty. 
    The first round between these two players is my_history[0] and their_history[0]
    The most recent round is my_history[-1] and their_history[-1]
    
    Returns 'c' or 'b' for collude or betray.
    '''
    
    #This example player always betrays.      
    return 'b'
--------------------------------------------------------------------------------
example2--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####

team_name = 'E2'
strategy_name = 'Alternate'
strategy_description = 'Collude, then alternate.'
    
def move(my_history, their_history, my_score, their_score):
    '''Make my move based on the history with this player.
    
    history: a string with one letter (c or b) per round that has been played with this opponent.
    their_history: a string of the same length as history, possibly empty. 
    The first round between these two players is my_history[0] and their_history[0]
    The most recent round is my_history[-1] and their_history[-1]
    
    Returns 'c' or 'b' for collude or betray.
    '''
    # This player colludes on even numbered rounds (first round is round #0).
    if len(my_history)%2 == 0:
        return 'c'
    else:
        return 'b'
    --------------------------------------------------------------------------------
example3--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####

team_name = 'E3'
strategy_name = 'Collude but retaliate'
strategy_description = '''\
Collude first round. Collude, except in a round after getting 
a severe punishment.'''
    
def move(my_history, their_history, my_score, their_score):
    '''Make my move based on the history with this player.
    
    history: a string with one letter (c or b) per round that has been played with this opponent.
    their_history: a string of the same length as history, possibly empty. 
    The first round between these two players is my_history[0] and their_history[0]
    The most recent round is my_history[-1] and their_history[-1]
    
    Returns 'c' or 'b' for collude or betray.
    '''
    if len(my_history)==0: # It's the first round; collude.
        return 'c'
    elif my_history[-1]=='c' and their_history[-1]=='b':
        return 'b' # Betray if they were severely punished last time,
    else:
        return 'c' # otherwise collude.--------------------------------------------------------------------------------
example4--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####

team_name = 'E4'
strategy_name = 'Use early history'
strategy_description = '''\
Collude first round. Compare all rounds to the previous round and 
assume opponent will behave the same as the first time the previous 
round's result occurred. If the previous round's result never has 
happened, collude except after being severly punished.'''
    
def move(my_history, their_history, my_score, their_score):
    '''Make my move based on the history with this player.
    
    history: a string with one letter (c or b) per round that has been played with this opponent.
    their_history: a string of the same length as history, possibly empty. 
    The first round between these two players is my_history[0] and their_history[0]
    The most recent round is my_history[-1] and their_history[-1]
    
    Returns 'c' or 'b' for collude or betray.
    '''
    if len(my_history)==0: # It's the first round: collude
        return 'c'
    else:
        # If there was a previous round just like the last one,
        # do whatever they did in the round that followed it
        
        # Reference last round
        recent_round_them = their_history[-1]
        recent_round_me = my_history[-1]
                    
        # Look at rounds before that one
        for round in range(len(my_history)-1):
            prior_round_them = their_history[round]
            prior_round_me = my_history[round]
            # If one matches
            if (prior_round_me == recent_round_me) and \
                    (prior_round_them == recent_round_them):
                return their_history[round]
        # No match found
        if my_history[-1]=='c' and their_history[-1]=='b':
            return 'b' # Betray if they were severely punished last time
        else:
            return 'c' # Otherwise collude.--------------------------------------------------------------------------------
example5--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####

team_name = 'E5'
strategy_name = 'Collude first 100 rounds unless betrayed. Betray 101st round forward.'
strategy_description = '''\
Betray if ever betrayed.
If I haven't been betrayed yet, I'll betray starting with the 100th round.
'''

import random
    
def move(my_history, their_history, my_score, their_score):
    '''Make my move based on the history with this player.
    
    history: a string with one letter (c or b) per round that has been played with this opponent.
    their_history: a string of the same length as history, possibly empty. 
    The first round between these two players is my_history[0] and their_history[0]
    The most recent round is my_history[-1] and their_history[-1]
    
    Returns 'c' or 'b' for collude or betray.
    '''
    # If the other player has betrayed or this is the last half of the game, 
    if 'b' in their_history or len(their_history)>100: 
        return 'b'               # Betray.
    else:
        return 'c'         # but 90% of the time collude
    
    
    --------------------------------------------------------------------------------
example6--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####

team_name = 'E6'
strategy_name = 'Collude until betrayed'
strategy_description = '''\
Collude first round. Collude, unless betrayed; then always betray.'''
    
def move(my_history, their_history, my_score, their_score):
    '''Make my move based on the history with this player.
    
    history: a string with one letter (c or b) per round that has been played with this opponent.
    their_history: a string of the same length as history, possibly empty. 
    The first round between these two players is my_history[0] and their_history[0]
    The most recent round is my_history[-1] and their_history[-1]
    
    Returns 'c' or 'b' for collude or betray.
    '''
    if 'b' in their_history:
        return 'b'
    else:
        return 'c'--------------------------------------------------------------------------------
example7--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####

team_name = 'E7'
strategy_name = 'Error'
strategy_description = 'return \'\', \' \', or int 4'
import random
    
def move(my_history, their_history, my_score, their_score):
    '''Make my move based on the history with this player.
    
    history: a string with one letter (c or b) per round that has been played with this opponent.
    their_history: a string of the same length as history, possibly empty. 
    The first round between these two players is my_history[0] and their_history[0]
    The most recent round is my_history[-1] and their_history[-1]
    
    Returns 'c' or 'b' for collude or betray.
    '''
    
    #This example player always betrays.      
    return random.choice(['', ' ', 4])
--------------------------------------------------------------------------------
team6--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####


import random

team_name = 'Byte Me' # Only 10 chars displayed.
strategy_name = 'The Social Experiment'
strategy_description = 'Start with collude until betrayed, then goes to soft majority'
    
def move_2(my_history, their_history, my_score, their_score):
    ''' Arguments accepted: my_history, their_history are strings.
    my_score, their_score are ints.
    
    Make my move.
    Returns 'c' or 'b'. 
    '''

    # my_history: a string with one letter (c or b) per round that has been played with this opponent.
    # their_history: a string of the same length as history, possibly empty. 
    # The first round between these two players is my_history[0] and their_history[0].
    # The most recent round is my_history[-1] and their_history[-1].
    
    # Analyze my_history and their_history and/or my_score and their_score.
    # Decide whether to return 'c' or 'b'.
    
    betrays = 0
    if not 'b' or 'c' in their_history:
        return('b')
    else:
        if len(their_history) == 0:
            return('b')
        else:
            if len(their_history) < 10:
                if 'b' in their_history:
                    return('b')
                else:
                    return('c')
            else:
                for i in their_history[-1:-10]:
                    if i is 'b': #if a syntax, then replace is with =
                        betrays = betrays + 1
                if betrays > 7.5:
                    if random.randint(1,10) < 9.5:
                        return('b')
                    else:
                        return('c')
                if betrays > 5.5 and betrays < 7.5:
                    if random.randint(1,10) < 7.5:
                        return('b')
                    else:
                        return('c')
                if betrays < 5.5:
                    if random.randint(1,10) > 4.5:
                        return('b')
                    else:
                        return('c')
                
def move(my_history, their_history, my_score, their_score):
    ''' Arguments accepted: my_history, their_history are strings.
    my_score, their_score are ints.
    
    Make my move.
    Returns 'c' or 'b'. 
    '''
    betrays = 0
    if not 'b' or 'c' in their_history:
        return('b')
    else:
        if len(their_history) == 0:
            return('c')
        else:
            if len(their_history) < 10:
                if 'b' == their_history[-1]:
                    if len(their_history) > 1:
                        if 'b' == their_history[-2]:
                            return('b')
                        else:
                            return('c')
                    else:
                        return('c')
                else:
                    return('b')
            else:
                for i in their_history[-1:-10]:
                    if i is 'b': #if a syntax, then replace is with =
                        betrays = betrays + 1
                if betrays > 7.5:
                    if random.randint(1,10) < 9.5:
                        return('b')
                    else:
                        return('c')
                if betrays > 5.5 and betrays < 7.5:
                    if random.randint(1,10) < 7.5:
                        return('b')
                    else:
                        return('c')
                if betrays < 5.5:
                    if random.randint(1,10) > 4.5:
                        return('b')
                    else:
                        return('c')
                
                    
def test_move(my_history, their_history, my_score, their_score):
    ''' Arguments accepted: my_history, their_history are strings.
    my_score, their_score are ints.
    
    Make my move.
    Returns 'c' or 'b'. 
    '''
    betrays = 0
    if not 'b' or 'c' in their_history:
        return('b')
    else:
        if len(their_history) == 0:
            return('c')
        else:
            if len(their_history) < 10:
                if 'bbb' in their_history:
                    return('b')
                else:
                    if random.randint(1,10) > 2.5:
                        return('c')
                    else:
                        return('b')
            else:
                for i in their_history[-1:-20]:
                    if i is 'b': #if a syntax, then replace is with =
                        betrays = betrays + 1
                if betrays > 7.5:
                    if random.randint(1,10) < 18.5:
                        return('b')
                    else:
                        return('c')
                if betrays > 5.5 and betrays < 15.5:
                    if random.randint(1,10) < 7.5:
                        return('b')
                    else:
                        return('c')
                if betrays < 10.5:
                    if random.randint(1,10) > 4.5:
                        return('b')
                    else:
                        return('c')
                
